# 太阳鸟游戏 - 微信小游戏合集

一个基于ECS架构的微信小游戏框架，支持多个子游戏的开发和管理。

## 项目简介

太阳鸟游戏是一个微信小游戏平台，包含：
- 🎮 **主菜单界面**：展示"太阳鸟游戏"标题，提供子游戏选择功能
- 🕹️ **网格移动游戏**：俯视角网格游戏，支持拖拽控制角色移动
- 🏗️ **ECS架构框架**：易于扩展的游戏架构，方便添加更多子游戏

## 技术特点

- **ECS架构**：Entity-Component-System设计模式，代码解耦，易于维护
- **模块化设计**：每个子游戏独立文件夹，互不干扰
- **通用组件系统**：核心组件和系统可复用，子游戏可自定义扩展
- **配置驱动**：游戏参数通过JSON配置文件管理
- **触摸控制**：完善的触摸事件处理系统
- **🎬 角色动画系统**：支持多帧精灵动画，状态驱动的动画切换

## 目录结构

\`\`\`
game/
├── game.js                 # 游戏入口
├── game.json              # 微信小游戏配置
├── project.config.json    # 项目配置
├── core/                  # 核心框架
│   ├── ecs/              # ECS框架核心
│   ├── components/       # 通用组件
│   │   └── AnimationComponent.js  # 🎬 动画组件
│   ├── systems/          # 通用系统
│   │   └── AnimationSystem.js     # 🎬 动画系统
│   ├── utils/            # 工具类
│   │   ├── SpriteGenerator.js     # 🎨 精灵图生成器
│   │   ├── ImageLoader.js         # 🖼️ 图片加载器
│   │   └── AnimationTester.js     # 🧪 动画测试器
│   ├── GameManager.js    # 游戏管理器
│   ├── Renderer.js       # 渲染管理器
│   ├── InputManager.js   # 输入管理器
│   └── ConfigManager.js  # 配置管理器
├── games/                # 子游戏
│   ├── MainMenu/         # 主菜单游戏
│   └── GridMove/         # 网格移动游戏
├── config/               # 配置文件
├── assets/               # 资源文件
└── docs/                 # 文档
\`\`\`

## 快速开始

### 1. 环境准备

- 安装[微信开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)
- 克隆或下载本项目

### 2. 打开项目

1. 启动微信开发者工具
2. 选择"小游戏"项目类型
3. 导入项目，选择 \`game\` 文件夹
4. 使用测试号或自己的AppID

### 3. 运行游戏

- 点击"编译"按钮即可运行
- 在模拟器中查看效果

## 游戏操作

### 主菜单
- 点击游戏按钮进入对应的子游戏
- 支持翻页浏览更多游戏（当游戏数量超过3个时）

### 网格移动游戏
- **拖拽手指**：控制角色移动方向
- 拖拽时会显示一条金色的方向线，帮助你看清楚方向
- 角色会沿着拖拽方向连续移动
- 摄像机会跟随角色移动，让角色始终在屏幕中心（除非到达边缘）
- 最终会自动对齐到网格点上
- 点击左上角的"返回"按钮回到主菜单

## 添加新游戏

### 步骤1：创建游戏文件夹

在 \`games/\` 目录下创建新游戏的文件夹，例如 \`MyGame/\`

### 步骤2：创建游戏主类

\`\`\`javascript
// games/MyGame/MyGame.js
export class MyGame {
  constructor(canvas, context, gameManager) {
    this.canvas = canvas;
    this.context = context;
    this.gameManager = gameManager;
  }
  
  // 静态方法：返回游戏显示名称
  static getDisplayName() {
    return '我的游戏';
  }
  
  // 静态方法：返回预览图路径
  static getPreviewImage() {
    return 'assets/images/MyGame/preview.png';
  }
  
  // 初始化游戏
  async init() {
    // 初始化代码
  }
  
  // 更新游戏逻辑
  update() {
    // 更新代码
  }
  
  // 渲染游戏画面
  render() {
    // 渲染代码
  }
  
  // 释放资源
  release() {
    // 清理代码
  }
}
\`\`\`

### 步骤3：注册游戏

在 \`game.js\` 中注册新游戏：

\`\`\`javascript
import { MyGame } from './games/MyGame/MyGame.js';

// 在init函数中注册
gameManager.registerGame('MyGame', MyGame);
\`\`\`

## 配置说明

### gameConfig.json

游戏参数配置：

\`\`\`json
{
  "screen": {
    "width": 750,
    "height": 1334
  },
  "grid": {
    "size": 40,          // 网格大小
    "cellSize": 18       // 单元格像素大小
  },
  "player": {
    "speed": 200         // 玩家移动速度（像素/秒）
  }
}
\`\`\`

### resourceConfig.json

资源文件配置：

\`\`\`json
{
  "images": {
    "myGame": {
      "sprite": "assets/images/MyGame/sprite.png"
    }
  }
}
\`\`\`

## ECS架构说明

详见 [ECS架构说明文档](./ECS架构说明.md)

## API文档

详见 [API文档](./API文档.md)

## 开发建议

1. **保持核心稳定**：不要轻易修改 \`core/\` 中的通用组件和系统
2. **游戏独立开发**：每个游戏在自己的文件夹中实现特有功能
3. **配置驱动**：尽量使用配置文件管理参数，避免硬编码
4. **及时更新文档**：添加新功能后更新相关文档

## 常见问题

### Q: 主界面一片空白怎么办？
A: 确保在每个游戏的 `render()` 方法中调用了 `world.render()`：

```javascript
render() {
  // 1. 清空画布
  this.renderer.clear('#1a1a2e');
  
  // 2. 调用世界渲染（这一步很重要！）
  this.world.render();
}
```

### Q: 微信小游戏报错 "global is not defined"？
A: 微信小游戏环境不支持 `global` 对象，应该使用 `GameGlobal`：

```javascript
// 错误写法
global.canvas = canvas;

// 正确写法
GameGlobal.canvas = canvas;
```

### Q: 如何修改网格大小？
A: 编辑 `config/gameConfig.json` 中的 `grid.size` 和 `grid.cellSize` 参数。

### Q: 如何添加图片资源？
A: 将图片放入 `assets/images/` 对应游戏的文件夹，然后在 `resourceConfig.json` 中配置路径。

### Q: 如何调试？
A: 在微信开发者工具中打开"调试器"，可以查看 console.log 输出和错误信息。

## 更新日志

### 2026-01-29 (物品栏动态顺序优化 🎒)
**✨ 物品栏改为按收集顺序动态显示**

根据游戏体验优化，物品栏不再使用固定位置，而是像真正的RPG背包一样按收集顺序显示：

- 🎒 **动态物品栏系统**
  - **改变前**: 物品栏预留固定位置（金币、种子、石块、土块）
  - **改变后**: 按照**收集的先后顺序**动态添加物品
  - **数据结构**: 从`Map`改为`Array`，记录收集时间戳
  - **好处**: 更符合真实游戏体验，玩家能看到收集历史
  
- 📐 **多行布局支持**
  - 自动计算每行可显示的物品数量
  - 支持多行换行显示，不受物品数量限制
  - 点击检测适配多行布局
  
- 🎨 **UI显示优化**
  - 空物品栏显示友好提示："物品栏空空如也..."
  - 标题改为"物品栏 (按收集顺序)"
  - 底部显示："共X种物品 | 总计Y个"
  - 数量显示改为 "×3" 格式，更清晰
  
- 💾 **InventoryComponent重构**
  ```javascript
  // 之前：固定顺序的Map
  items = new Map([
    ['coin', 5],
    ['seed', 3]
  ])
  
  // 现在：按时间排序的Array
  items = [
    {type: 'coin', count: 5, timestamp: 1706505600000},
    {type: 'seed', count: 3, timestamp: 1706505630000}
  ]
  ```

**收集体验示例**：
```
1. 收集第1个金币 → 物品栏: [金币×1]
2. 收集第1个种子 → 物品栏: [金币×1, 种子×1]
3. 收集第2个金币 → 物品栏: [金币×2, 种子×1]
4. 收集第1个石块 → 物品栏: [金币×2, 种子×1, 石块×1]
```

每个物品的位置反映了你的探索历程！🗺️✨

### 2026-01-29 (物品渲染系统修复 🔧)
**🐛 修复了物品不显示的问题**

经过调试，发现并修复了物品无法在地图上显示的关键问题：

- 🔧 **RenderSystem组件要求修复**
  - **问题**: RenderSystem的`requiredComponents`设置为`[PositionComponent, RenderComponent]`
  - **影响**: 物品实体只有`PositionComponent`和`ItemComponent`，没有`RenderComponent`，导致它们不会被传递给渲染系统
  - **修复**: 改为只需要`[PositionComponent]`，让所有有位置的实体都能被渲染
  
- 🎨 **物品渲染逻辑优化**
  - 在render方法中优先检查`ItemComponent`，如果存在就使用专用的物品渲染
  - 添加cellSize参数到RenderSystem构造函数，支持动态物品大小计算
  - 修复硬编码的cellSize=50问题，改为使用配置中的实际值
  
- 🚀 **初始化顺序修复**
  - **问题**: `_initializeItemGeneration()`在`_createTerrain()`中调用，但此时玩家还未创建
  - **修复**: 移到`_createPlayer()`之后调用，确保玩家实体存在
  - **结果**: 物品生成器能正确获取玩家位置，设置禁止生成区域

- ⚡ **性能优化**
  - 添加空值检查，避免渲染过程中的错误
  - 优化排序逻辑，正确处理没有RenderComponent的实体
  - 改进透明度处理，使用Canvas的save/restore机制

**修复后的效果**：
```
现在游戏启动后会看到：
- 🪙 金色圆形的金币（带内部高光特效）
- 🌱 棕色菱形的种子（中间有装饰小点）
- 物品散布在可行走的陆地区域
- 玩家周围3格内不会有物品
```

### 2026-01-29 (物品收集系统重大更新！🎁)
**🪙 全新物品收集系统 - 让游戏更有趣！**

这是一次重要的游戏性更新，为网格移动游戏引入了完整的物品收集系统！

- 🎁 **智能物品生成系统**
  - 实现了ItemGenerator物品生成器，可以在地图上随机生成金币和种子
  - 支持地形感知生成：物品只会出现在可行走的陆地上，不会生成在水域
  - 智能避让：玩家起始位置周围3格范围内不会生成物品，确保游戏体验
  - 可配置生成数量：金币8个，种子6个，分布在30×30的大地图上

- 🎒 **动态物品栏系统**
  - 重构UIManager，移除硬编码的剑、盾等物品
  - 实现InventoryComponent组件，支持动态物品数据管理
  - 美观的UI显示：使用emoji图标(🪙🌱)和数量显示
  - 实时更新：收集物品后物品栏立即更新显示

- 🎯 **精确碰撞检测**
  - 实现CollectionSystem收集系统，处理玩家与物品的交互
  - 精确碰撞：只有角色到达格子中心才能收集物品，不是边缘碰撞
  - 复用现有GridSystem的格子中心检测逻辑(distance < 3像素)
  - 收集反馈：音效提示、控制台消息、UI更新

- 🎨 **精美物品渲染**
  - 扩展RenderSystem支持物品渲染
  - 金币：金色圆形，带有内部高光特效
  - 种子：棕色菱形，中间有小点装饰
  - 支持透明度渐变收集特效
  - 不同形状：圆形、方形、菱形可扩展

- 🏗️ **可扩展架构设计**
  - 基于ECS架构，完美集成现有系统
  - ItemComponent支持多种物品类型：收集型、阻挡型、地形属性型
  - 为未来功能预留接口：石块(阻挡移动)、土块(地形属性)
  - 模块化设计，易于添加新物品类型

- ⚡ **性能优化**
  - 空间分区：使用网格坐标快速定位物品
  - 智能渲染：已收集物品自动隐藏，减少绘制开销
  - 内存管理：支持已收集物品的清理机制
  - 批量操作：物品生成和UI更新都经过优化

**使用方法：**
```javascript
// 游戏会自动生成物品，玩家只需要：
// 1. 拖拽角色移动到金币或种子上
// 2. 到达格子中心时自动收集
// 3. 查看物品栏Tab查看收集进度
// 4. 金币和种子数量实时显示

// 开发者可以手动生成物品：
itemGenerator.generateItemAt('coin', 10, 15, world);
itemGenerator.generateItemAt('seed', 12, 18, world);
```

**技术架构：**
```
新增组件和系统：
├── ItemComponent.js          # 物品属性和状态管理
├── InventoryComponent.js     # 玩家物品栏数据
├── CollectionSystem.js       # 收集逻辑和碰撞检测
├── ItemGenerator.js          # 物品生成和配置
└── UIManager.js (重构)       # 动态物品栏显示

集成现有系统：
├── RenderSystem.js (扩展)    # 支持物品渲染
├── GridMoveGame.js (更新)    # 系统注册和初始化
└── 与地形系统完美集成        # 物品只生成在可行走区域
```

现在的游戏体验就像真正的RPG：在美丽的岛屿上探索，收集散落的宝藏，每次游戏都有不同的物品分布！🏝️✨

### 2026-01-29 (动画系统优化 🎨)
**修复眼睛抖动和增强呼吸效果**

针对用户反馈的动画问题进行了精细优化：

- 🩹 **修复眼睛抖动问题**
  - 将头部和眼睛位置固定，不再随身体移动
  - 走路时只有身体和四肢会摆动，头部保持稳定
  - 眼睛坐标统一使用相对头部中心的定位系统
  - 移动动画更加自然流畅

- 😮‍💨 **增强站立呼吸效果**
  - 改进呼吸动画算法，使用明确的身体缩放参数
  - frame 0: 正常状态
  - frame 1: 吸气状态（身体纵向拉伸10%，上移1像素）
  - frame 2: 呼气状态（身体纵向压缩5%，下移1像素）
  - 呼吸节奏更加明显，视觉效果显著提升

- 🏗️ **代码架构优化**
  - 重构`_drawCharacterBase()`方法，支持参数化的身体缩放和偏移
  - 新增`_drawLimbsWalking()`方法，专门处理走路时的四肢摆动
  - 删除过时的`_applyBreathEffect()`和`_applyWalkEffect()`方法
  - 代码更加清晰易读，维护性更好

- 🎨 **动画细节改进**
  - 走路动画的四肢摆动幅度调整为±3像素
  - 身体上下摆动幅度保持±2像素
  - 手臂和腿部使用相反的摆动相位，模拟真实走路动作
  - 所有动画参数都经过精心调校

**技术实现：**
```javascript
// 站立呼吸效果
generateIdleFrames() {
  // frame 0: bodyScaleY=1.0, bodyOffsetY=0
  // frame 1: bodyScaleY=1.1, bodyOffsetY=-1  (吸气)
  // frame 2: bodyScaleY=0.95, bodyOffsetY=1  (呼气)
}

// 走路动画
generateWalkFrames() {
  // 头部位置固定 headY = center - 8
  // 身体随步伐摆动 bodyY = center + 2 + bobOffset
  // 四肢交替摆动 leftSwing = -rightSwing
}
```

现在角色动画更加生动自然，眼睛不再抖动，呼吸效果也更加明显，玩家体验大幅提升！✨

### 2026-01-29 (角色动画系统重大更新！🎬)
**🎨 全新角色动画系统 - 让游戏角色栩栩如生！**

这是一次革命性的更新，为网格移动游戏引入了完整的角色动画系统！

- 🎭 **智能动画生成**
  - 实现了SpriteGenerator精灵图生成器，可以程序化生成角色动画帧
  - 支持走路动画（4帧）和站立呼吸动画（3帧）
  - 支持四个方向（上下左右）的完整动画序列
  - 48x48像素的精美像素风格角色设计

- 🎬 **状态驱动动画系统**
  - 新增AnimationComponent组件，管理动画状态和帧切换逻辑
  - 新增AnimationSystem系统，根据角色移动状态自动切换动画
  - 支持动画循环播放、帧率控制、方向切换
  - 与现有MovementSystem完美集成，实现智能动画切换

- 🖼️ **资源管理优化**
  - 实现ImageLoader图片加载器，提供异步加载和缓存管理
  - 支持批量图片预加载，优化游戏启动性能
  - 内存使用监控和资源清理机制
  - 微信小游戏环境完美兼容

- 🧪 **完善的测试系统**
  - 实现AnimationTester动画测试器，确保系统稳定性
  - 自动化测试覆盖动画生成、组件初始化、系统集成等
  - 手动测试功能，支持各种动画状态的验证
  - 详细的测试报告和错误诊断

- 🏗️ **架构升级**
  ```
  新增核心组件：
  ├── AnimationComponent.js     # 动画状态管理
  ├── AnimationSystem.js        # 动画逻辑处理
  ├── SpriteGenerator.js        # 动画图片生成
  ├── ImageLoader.js            # 资源加载管理
  └── AnimationTester.js        # 测试验证工具
  
  系统集成：
  MovementSystem → AnimationSystem → RenderSystem
  ```

- ⚡ **性能优化**
  - 离屏Canvas预渲染技术，减少实时绘制开销
  - 智能状态缓存，避免重复的动画切换计算
  - 帧率自适应控制，平衡视觉效果和性能消耗

- 🎮 **用户体验提升**
  - 角色移动时播放流畅的走路动画
  - 静止时播放自然的呼吸动画
  - 方向切换时动画无缝过渡
  - UI界面显示当前动画状态信息

**使用方法：**
```javascript
// 动画系统会自动根据角色状态切换动画
// 移动时：播放walk动画
// 静止时：播放idle动画
// 支持上下左右四个方向

// 手动控制动画（高级用法）
animationSystem.playEntityAnimation(player, 'walk', 'right');
```

现在的游戏体验就像真正的RPG游戏：角色有了生动的动画表现，每个动作都充满了生命力！🎮✨

### 2026-01-29 (移动系统问题修复 🐛)
**重要修复：解决移动停顿和坐标跳跃问题**

修复了两个严重影响游戏体验的移动系统bug：

- 🐛 **问题1：移动停顿感**
  - **原因**：GridSystem和DragSystem使用不同的距离阈值判断是否到达目标
  - **现象**：角色移动时会出现明显的停顿，不流畅
  - **修复**：
    - 统一GridSystem和DragSystem的距离阈值为3像素
    - GridSystem从1像素提高到3像素，减少过早触发对齐
    - DragSystem从5像素降低到3像素，保持一致性

- 🐛 **问题2：纵向坐标突然改变**
  - **原因**：GridSystem使用`Math.round`计算网格坐标
  - **现象**：向左移动时，纵向坐标会突然跳到另一行
  - **根本原因**：当角色纵向位置稍微偏离中心时（比如25.6），`Math.round(25.6/50)=1`会错误地四舍五入到下一行
  - **修复**：
    - 改用目标位置计算网格坐标：`Math.floor(targetX / cellSize)`
    - 直接对齐到目标位置，不重新计算中心点
    - 保证移动方向的稳定性

- ⚡ **MovementSystem优化**
  - 使用归一化方向向量保持移动方向稳定
  - 降低到达目标的阈值到0.5像素，提高精确度
  - 避免因浮点数误差导致的方向偏移

**技术细节：**
```javascript
// 修复前（GridSystem）：
const nearestGridX = Math.round(position.x / this.cellSize);  // ❌ 会导致坐标跳跃
const nearestGridY = Math.round(position.y / this.cellSize);  // ❌

// 修复后（GridSystem）：
const targetGridX = Math.floor(movement.targetX / this.cellSize);  // ✅ 使用目标位置
const targetGridY = Math.floor(movement.targetY / this.cellSize);  // ✅ 保持方向稳定
position.x = movement.targetX;  // ✅ 直接对齐到目标
position.y = movement.targetY;  // ✅
```

现在移动系统变得非常流畅和精确！角色会严格按照你拖拽的方向移动，不会再出现意外的坐标跳跃！🎮✨

### 2026-01-29 (地形系统重大更新！)
**🌊 地形系统全面实现 - 游戏世界更加真实！**

这是一次革命性的更新，为网格移动游戏引入了完整的地形系统！

- 🗺️ **地形类型系统**
  - 实现了水格子（蓝色，不可行走）和土格子（棕色，可行走）
  - 属性驱动架构：每种地形都有 `walkable` 属性
  - 易于扩展：未来可轻松添加山地、森林、沙漠等新地形

- 🎲 **智能随机地图生成**
  - 圆形岛屿算法：从中心向外扩展形成自然的陆地形状
  - 连通性保证：使用BFS算法确保所有陆地相互连通，无孤岛
  - 边缘水域控制：地图外围2-5格范围合理分布水域
  - 可配置参数：陆地比例、中心半径、边缘范围等

- 🚫 **预判断移动系统**
  - 智能移动检查：拖拽时立即计算目标格子是否可行走
  - 即时反馈：尝试移动到水域时立即阻止，显示"阻挡"状态
  - 性能优化：基于网格坐标计算，避免像素级检查

- 🎮 **玩家体验优化**
  - 智能起始位置：自动寻找可行走的起始点
  - 螺旋搜索算法：如果中心被水覆盖，向外搜索合适位置
  - 视觉差异化：水域和陆地有明显的颜色区别和边框效果

- 🏗️ **技术架构升级**
  ```
  新增组件和系统：
  ├── TerrainComponent.js     # 地形数据管理
  ├── TerrainSystem.js        # 地形渲染和验证
  ├── MapGenerator.js         # 随机地图生成器
  └── TerrainTypes.js         # 地形类型定义
  
  集成现有系统：
  ├── DragSystem.js          # 添加地形检查
  ├── GridSystem.js          # 添加安全验证
  └── GridMoveGame.js        # 系统集成
  ```

- ⚙️ **配置系统扩展**
  - 新增 `terrain` 配置节点
  - 可调参数：`landRatio`, `centerRadius`, `edgeWaterRange`
  - 调试选项：`visualizeInConsole` 在控制台显示地图

- 🎨 **渲染性能优化**
  - 离屏Canvas预渲染：地形背景只渲染一次
  - 缓存机制：避免每帧重绘地形
  - 微信小游戏兼容：支持微信环境的Canvas创建

**使用方法：**
```javascript
// 地形配置示例
"terrain": {
  "landRatio": 0.65,          // 65%陆地
  "centerRadius": 0.35,       // 35%中心半径
  "edgeWaterRange": 3,        // 边缘3格水域
  "maxRetries": 5,            // 最多重试5次
  "enableRandomGeneration": true,
  "visualizeInConsole": true  // 控制台显示地图
}
```

现在的游戏体验就像真正的冒险游戏：玩家在一个美丽的岛屿上探索，不能走到水里，每次游戏都有不同的地图布局！🏝️✨

### 2026-01-29 (晚上更新10)
**GridMove游戏UI全面升级**
- 🎨 **底部UI区域重新设计**
  - 返回按钮移至底部左侧，更方便操作
  - 实现了Tab切换系统，支持多页面内容展示
  - 底部UI背景半透明深色，更有科技感
  
- 📑 **多Tab界面实现**
  - **信息Tab**：显示角色的详细信息
    - 网格坐标 (gridX, gridY)
    - 像素位置 (x, y)
    - 移动方向（上/下/左/右/无）
    - 移动状态（是/否）
  - **物品Tab**：物品栏系统（为后续功能做准备）
    - 单行可翻页的物品按钮展示
    - 支持物品选中（点击高亮显示）
    - 空物品栏显示为灰色
    - 非空物品可点击选中使用
    
- 🎯 **触摸控制优化**
  - 在底部UI区域按下不会触发拖动移动
  - UI点击与游戏拖动完全分离
  - 点击返回按钮/Tab/物品都有响应
  
- 🏗️ **新增UIManager组件**
  - 统一管理所有UI元素的绘制和交互
  - 支持Tab切换、按钮点击、物品选择
  - 易于扩展，后续可以轻松添加更多UI功能
  
**技术架构：**
```
GridMove/
├── GridMoveGame.js      # 主游戏类
├── systems/
│   ├── DragSystem.js    # 拖动控制（新增UI区域检测）
│   └── ...
└── ui/
    └── UIManager.js     # 🆕 UI管理器
```

**UI布局：**
```
┌─────────────────────┐
│  顶部区域 (100px)    │
├─────────────────────┤
│                     │
│   游戏区域          │ ← 网格和角色
│  (934px高)          │
│                     │
├─────────────────────┤
│ [返回主菜单]         │ ← 返回按钮
│ [信息] [物品]       │ ← Tab标签
│ ─────────────────── │
│  Tab内容区域        │ ← 信息显示/物品栏
└─────────────────────┘
```

现在游戏的UI更加完整和专业了！🎮✨

### 2026-01-29 (晚上更新9)
**调整游戏区域布局，为UI预留空间**
- 🎨 网格限制显示在屏幕中间偏上的区域
  - 顶部空出100像素（可以放标题、分数等）
  - 底部空出300像素（可以放控制按钮、信息面板等）
  - 网格只在中间区域显示，不会占满全屏
  - 使用 `clip()` 裁剪，网格不会溢出到UI区域
- 🎯 优化摄像机和坐标系统
  - 摄像机计算基于游戏区域尺寸，而不是整个屏幕
  - 玩家在游戏区域内居中显示
  - 绘制了游戏区域边框（灰色边框）便于识别范围
- 📐 新的布局结构
  ```
  ┌─────────────────────┐
  │  顶部区域 (100px)    │ ← UI空间：标题、分数
  ├─────────────────────┤
  │                     │
  │   游戏区域          │ ← 网格显示区域
  │  (734px高)          │   有裁剪边界
  │                     │
  ├─────────────────────┤
  │  底部区域 (300px)    │ ← UI空间：按钮、信息
  └─────────────────────┘
  ```

**配置参数：**
- `gameAreaTop`: 100px（顶部预留空间）
- `gameAreaBottom`: 300px（底部预留空间）
- 游戏区域高度：1334 - 100 - 300 = 934px

现在有充足的空间来添加各种UI元素了！🎮

### 2026-01-29 (晚上更新8)
**修复移动中突然返回之前格子的bug**
- 🐛 修复移动时突然跳回之前格子的严重bug
  - **问题原因：** 每帧都更新 `grid.gridX/gridY`，导致移动中目标突变
  - **具体场景：**
    ```
    角色从格子2移动到格子3（目标是格子3中心）
    ↓
    移动到一半，position.x = 126（刚越过格子边界150）
    ↓
    _updateGridPosition: grid.gridX = floor(126/50) = 2（变成3了！）
    ↓
    重新计算目标：grid.gridX(3) + 1 = 4（目标突然变了！）
    ↓
    角色突然改变方向去格子4，看起来像"返回"或"跳跃"
    ```
  - **修复方案：** 只在关键时刻更新网格坐标
    - 在格子中心准备开始新移动时更新
    - 到达目标停止时更新
    - 移动过程中不更新，避免目标突变
  - 现在移动流畅稳定，不会突然跳跃！

**修复前后对比：**
```javascript
// ❌ 修复前：每帧都更新
update() {
  this._updateGridPosition(position, grid);  // 每帧更新！
  if (isAtGridCenter) {
    targetGrid = grid.gridX + direction.x;  // 基于不断变化的grid计算
  }
}

// ✅ 修复后：只在关键时刻更新
update() {
  if (isAtGridCenter || !movement.moving) {
    this._updateGridPosition(position, grid);  // 到达格子中心才更新
    targetGrid = grid.gridX + direction.x;  // 基于稳定的grid计算
  }
  // 移动中不更新grid，目标不会突变
}
```

### 2026-01-29 (晚上更新7)
**扩大视野显示更多网格**
- 🔍 进一步扩大视野让横向能看到15个格子
  - `gridSize`: 20 → 30（30×30超大世界！）
  - `cellSize`: 80 → 50（单元格进一步缩小）
  - `playerSpeed`: 400 → 250（速度相应调整）
  - 角色半径：38 → 23像素
  - **屏幕宽度750px ÷ 50px = 15个格子（横向）**
  - **屏幕高度1334px ÷ 50px = 约26.7个格子（纵向）**
  - 现在可以看到更广阔的世界！
  - 总共900个格子（30×30），巨大的探索空间

### 2026-01-29 (晚上更新6)
**修复松手瞬移问题**
- 🐛 修复松手时的瞬移感觉
  - **问题：** 松手时调用 `_snapToGridCenter()` 会瞬间跳到格子中心
  - 有时候往后拖回前面的网格，有时候突然瞬移到下一格
  - 体验不自然，像传送一样
  - **修复：** 移除强制对齐，改为自然停止
  - 松手后角色继续以当前速度移动到目标格子
  - 到达目标格子后自然停止
  - 不再有瞬移感，移动更流畅自然！

**新的逻辑：**
```javascript
// 松手时
onTouchEnd: () => {
  this.nextDirection = null;  // 清除输入
  // 不强制对齐！让角色自然移动
}

// update中
if (!this.nextDirection) {
  if (movement.moving && movement.targetX !== null) {
    continue;  // 继续移动到目标格子
  } else {
    movement.stop();  // 到达后自然停止
  }
}

// 下次拖动时
if (isAtGridCenter || !movement.moving) {
  // 在格子中心 或 已停止，都可以开始新移动
  movement.setTarget(...);
}
```

现在松手后角色会平滑地移动到目标格子，再也不会瞬移了！✨

### 2026-01-29 (晚上更新5)
**缩小镜头显示更多网格**
- 🔍 调整视野让同屏能看到更多格子
  - `gridSize`: 5 → 20（20×20大世界！）
  - `cellSize`: 150 → 80（单元格缩小）
  - `playerSpeed`: 750 → 400（速度相应调整）
  - 角色半径：73 → 38像素
  - **屏幕宽度750px ÷ 80px = 约9.4个格子**
  - **屏幕高度1334px ÷ 80px = 约16.7个格子**
  - 现在可以看到更广阔的游戏世界！
  - 总共400个格子（20×20），有更大的探索空间

### 2026-01-29 (晚上更新4)
**优化网格大小和修复移动顿挫感**
- 📏 调整网格大小到更合适的尺寸
  - `gridSize`: 3 → 5（5×5网格更合适）
  - `cellSize`: 300 → 150（单元格缩小一半）
  - `playerSpeed`: 1500 → 750（速度相应调整）
  - 角色半径：148 → 73像素
  - 现在大小刚刚好，不会太大也不会太小！
- 🐛 **修复同方向移动的顿挫感**
  - **原因：** 每次到达格子中心都会重新设置速度和目标，即使方向没变
  - 就像开车每隔100米就松油门再踩，会有顿一下的感觉
  - **修复：** 新增 `currentDirection` 记录当前移动方向
  - 只有方向改变时才重新设置速度
  - 同方向连续移动时只更新目标位置，保持速度不变
  - 现在移动流畅丝滑！✨

**技术细节：**
```javascript
// 检查方向是否改变
const directionChanged = !this.currentDirection || 
                         this.currentDirection.x !== this.nextDirection.x || 
                         this.currentDirection.y !== this.nextDirection.y;

if (directionChanged) {
  // 方向改变：重新设置速度和目标
  movement.setVelocity(...);
  movement.setTarget(...);
  this.currentDirection = { ...this.nextDirection };
} else {
  // 方向相同：只更新目标，保持速度（流畅！）
  movement.setTarget(...);
}
```

### 2026-01-29 (晚上更新3)
**放大网格和角色的屏幕显示**
- 📏 调整网格配置让格子看起来更大
  - `gridSize`: 40 → 3（网格从40×40改为3×3）
  - `cellSize`: 18 → 300（单元格大小放大）
  - `playerSpeed`: 200 → 1500（移动速度相应提高）
  - 角色半径：8 → 148像素（cellSize/2 - 2）
  - **现在每个格子都占据屏幕的很大一部分，看起来清晰多了！**
  - 只有3×3=9个格子，角色显得很大
- 🐛 修复配置不生效的问题
  - **原因：** `_loadConfig()` 会从 `gameConfig.json` 读取值，覆盖代码中的设置
  - 同时更新了配置文件和代码中的默认值
  - 现在两边都是新的值，确保生效！
- 🎨 角色颜色改为绿色（#00FF00）验证编译正常

### 2026-01-29 (晚上更新2)
**修复拖动卡死bug**
- 🐛 修复松手再拖动有时候完全卡死的问题
  - **原因：** 松手时角色可能停在"接近但不完全在"格子中心的位置
  - 再次拖动时，`_isAtGridCenter()` 返回false，无法开始新移动
  - 角色既没有目标，又不在格子中心，就卡住了
  - **修复：** 松手时强制对齐到最近的格子中心
  - 新增 `_snapToGridCenter()` 方法
  - 确保每次松手后角色都精确停在格子正中心
  - 下次拖动时一定能响应！
- 🐛 修复 `getEntities is not a function` 错误
  - System基类没有 `getEntities()` 方法
  - 改用在 `update()` 中保存 `playerEntity` 引用
  - 松手时直接使用保存的引用进行对齐

**技术细节：**
```javascript
// 在update中保存玩家引用
update(deltaTime, entities) {
  for (const entity of entities) {
    this.playerEntity = entity;  // 保存引用
    // ...
  }
}

// 松手时使用保存的引用
_snapToGridCenter() {
  if (!this.playerEntity) return;
  const position = this.playerEntity.getComponent(PositionComponent);
  // 计算并对齐到格子中心
}
```

这样就彻底解决了卡死问题！✨

### 2026-01-29 (晚上更新)
**修复基于网格移动的关键bug**
- 🐛 修复GridComponent坐标不更新的问题
  - 角色移动后网格坐标(gridX/gridY)没有更新
  - 导致 `_isAtGridCenter()` 永远基于初始位置判断
  - 新增 `_updateGridPosition()` 方法实时更新网格坐标
- 🐛 修复松手后角色继续移动的问题
  - 松手时虽然清除了nextDirection，但没有清除movement的target
  - 角色会继续移动到之前设置的目标格子
  - 现在松手时会立即调用 `clearTarget()` 和 `stop()`
- 🐛 修复方向切换延迟问题
  - 移动中如果不在格子中心会跳过设置新方向
  - 新方向被记录但不会立即生效
  - 重构update逻辑：在格子中心才响应方向，其他时间保持当前移动
- ✅ 优化require导入方式
  - 将GridComponent改为标准ES6 import
  - 避免运行时require带来的问题

**现在的移动逻辑：**
1. 每帧都更新网格坐标（根据像素位置）
2. 只有在格子中心才能开始新的移动
3. 移动到一半改变方向会排队，到达格子中心后执行
4. 松手立即停止，不会有惯性
5. 始终保持网格对齐！

### 2026-01-29 (下午更新5)
**基于网格的移动系统重构**
- ✅ 修复拖拽线刚按下就显示的问题
  - 只有拖动距离超过10像素才显示连线
  - 刚按下时不会看到意外的线
- ✅ 松开手指后角色立即停止
  - 检测到无方向输入时立即清除移动目标
  - 角色不会继续惯性移动
- ✅ 实现基于网格的移动机制
  - 角色一次只移动一个格子
  - 移动到格子中间时可以切换方向
  - 格子之间移动时方向会排队，到达下一个格子后执行
  - 到达边界时自动停止
  - 更符合网格游戏的经典玩法！

### 2026-01-29 (下午更新4)
**角色大小和边界限制优化**
- ✅ 角色大小与网格匹配
  - 角色半径现在是单元格大小的一半（减去2像素边距）
  - cellSize=60时，角色半径=28，完美填充网格
- ✅ 限制角色在有效网格范围内移动
  - 修复边界计算：从单元格中心点计算
  - 最小位置：第一个格子中心 = cellSize/2
  - 最大位置：最后一个格子中心 = (gridSize-1) * cellSize + cellSize/2
  - 角色不会超出网格边界了！

### 2026-01-29 (下午更新3)
**增强调试信息和方向切换**
- ✅ 添加角色网格信息显示
  - 显示网格坐标：(gridX, gridY)
  - 显示像素位置：(x, y)
  - 显示是否正在移动
- ✅ 修复方向切换不响应的问题
  - 问题原因：角色移动中会忽略新的方向输入
  - 解决方案：移除`movement.moving`检查，允许移动中切换方向
  - 现在可以随时切换方向，角色立即响应！

### 2026-01-29 (下午更新2)
**修复方向判断问题**
- ✅ 修复方向显示与实际移动不一致的bug
  - 问题原因：每次移动都重置拖拽起点，导致方向判断错误
  - 解决方案：保持从按下点计算方向，不在移动过程中重置起点
  - 现在方向显示和角色移动完全一致了！

### 2026-01-29 (下午更新1)
**网格移动游戏优化**
- ✅ 修复网格线显示问题（之前有些地方只有横线或竖线）
- ✅ 修复拖拽线偏移问题（现在准确显示在手指位置）
- ✅ 提高角色移动响应速度（降低触发距离阈值从20到10）
- ✅ 添加方向调试显示（屏幕下方中间显示"无/上/下/左/右"）
- ✅ 放大网格和角色
  - 网格从40x40改为10x10
  - 单元格大小从18px改为60px
  - 角色半径从8px改为20px
  - 移动速度从200提升到300

### 2026-01-29 (上午)
**网格移动游戏改进**
- ✅ 修复返回按钮无响应的问题
- ✅ 添加拖拽方向线提示（金色线条）
- ✅ 实现摄像机跟随角色移动
  - 角色始终在屏幕中心（除非到达世界边缘）
  - UI元素（返回按钮）固定在屏幕上不随摄像机移动

## 后续计划

- [ ] 添加音效系统
- [ ] 添加更多示例游戏
- [ ] 完善资源加载管理
- [ ] 添加游戏数据存储
- [ ] 优化性能和渲染

## 贡献

欢迎提交问题和改进建议！

## 许可

MIT License
